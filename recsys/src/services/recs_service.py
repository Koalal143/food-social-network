from typing import Annotated, Any

from dishka.integrations.faststream import FromDishka
from faststream import Context

from src.repositories.embeddings import EmbeddingsRepository
from src.repositories.postgres import (
    FeedbackType,
    ImpressionSource,
    RecipeRepository,
    UserFeedback,
    UserFeedbackRepository,
    UserImpression,
    UserImpressionRepository,
)
from src.repositories.qdrant import QdrantRepository
from src.schemas.tasks import AddImpressionRequest


class RecommendationService:
    def __init__(
        self,
        recipe_repo: RecipeRepository,
        feedback_repo: UserFeedbackRepository,
        impression_repo: UserImpressionRepository,
        qdrant_repo: QdrantRepository,
        embeddings_repo: EmbeddingsRepository,
    ) -> None:
        self.recipe_repo = recipe_repo
        self.feedback_repo = feedback_repo
        self.impression_repo = impression_repo
        self.qdrant_repo = qdrant_repo
        self.embeddings_repo = embeddings_repo

    async def add_feedback(self, user_id: int, recipe_id: int, feedback_type: FeedbackType) -> UserFeedback:
        return await self.feedback_repo.add_feedback(user_id, recipe_id, feedback_type)

    async def delete_feedback(self, user_id: int, recipe_id: int, feedback_type: FeedbackType) -> None:
        return await self.feedback_repo.delete_feedback(user_id, recipe_id, feedback_type)

    async def add_impression(self, user_id: int, recipe_id: int, source: ImpressionSource) -> UserImpression:
        return await self.impression_repo.add_impression(user_id, recipe_id, source)

    async def add_impressions_bulk(self, impressions: list[AddImpressionRequest]) -> list[UserImpression]:
        impressions_list = [impression.model_dump() for impression in impressions]
        return list(await self.impression_repo.add_impressions_bulk(impressions_list))

    async def delete_recipe(self, recipe_id: int) -> None:
        await self.recipe_repo.delete_recipe(recipe_id)
        return await self.qdrant_repo.delete_recipe(recipe_id)

    async def add_recipe_with_embedding(
        self, author_id: int, recipe_id: int, title: str, tags: str, payload: dict[str, Any] | None = None
    ) -> None:
        embedding = await self.embeddings_repo.get_embedding(f"{title}, {tags}")
        await self.recipe_repo.add_recipe(recipe_id, author_id)
        return await self.qdrant_repo.add_recipe(recipe_id, embedding, payload)

    async def get_recommendations(
        self,
        query_vector: list[float],
        limit: int = 10,
        exclude_ids: list[int] | None = None,
    ) -> Any:
        return await self.qdrant_repo.get_recommendations(query_vector, limit, exclude_ids)

    async def get_vector_based_recommendations(
        self, user_id: int, limit: int = 10, fetch_k: int = 20, lambda_mult: float = 0.5, *, exclude_viewed: bool = True
    ) -> list[dict[str, Any]]:
        """
        Get recommendations with usage of embedding algorithm

        Args:
            user_id: user id to get recommendations for
            limit: Number of recommendations to return
            fetch_k: Number of candidates to fetch from the vector database
            lambda_mult: Lambda multiplier for balancing relevance and diversity
            exclude_viewed: Exclude viewed recipes from the recommendations

        """
        from src.algorithms.recommendation_algorithm import RecommendationAlgorithm

        algorithm = RecommendationAlgorithm(
            feedback_repo=self.feedback_repo,
            impression_repo=self.impression_repo,
            qdrant_repo=self.qdrant_repo,
            embeddings_repo=self.embeddings_repo,
            recipe_repo=self.recipe_repo,
        )

        return await algorithm.get_recommendations(
            user_id=user_id, limit=limit, fetch_k=fetch_k, lambda_mult=lambda_mult, exclude_viewed=exclude_viewed
        )

    async def get_all_recipe_ids(self) -> list[int]:
        return await self.qdrant_repo.get_all_recipe_ids()


# Because we are using FromDishka type, we need to somehow ignore this type for the faststream autogenerated docs
# By using Context object, we set it None for default, but it will be replaced with actual value in runtime
RecommendationServiceDependency = Annotated[
    FromDishka[RecommendationService], Context("mock_for_docs_correct_generation", default=None)
]
